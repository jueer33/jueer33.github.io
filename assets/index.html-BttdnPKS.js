import{_ as s,c as t,e as i,o as a}from"./app-CeRryCsJ.js";const n={};function d(r,e){return a(),t("div",null,[...e[0]||(e[0]=[i(`<h2 id="_8-nexttick" tabindex="-1"><a class="header-anchor" href="#_8-nexttick"><span>8.nexttick</span></a></h2><h2 id="vue的页面渲染-异步更新" tabindex="-1"><a class="header-anchor" href="#vue的页面渲染-异步更新"><span>vue的页面渲染-异步更新</span></a></h2><blockquote><p>vue中的页面渲染实际是异步渲染的——为什么需要异步渲染呢？</p></blockquote><p>如果是同步渲染的话，修改一次数据就会进行一次页面的数据更新，假设短时间内我对同一个数据修改了多次，最终页面中显示的数据实际只有最后修改后的值，但是中间更新过程中也执行了多次页面更新代码，这之间的计算实际用户是不可见的，并没有必要。</p><p>而异步更新，vue中会把<strong>同一事件循环中所有的数据变更</strong> 收集起来，<strong>只更新一次 DOM</strong>。</p><h2 id="异步更新实现原理" tabindex="-1"><a class="header-anchor" href="#异步更新实现原理"><span>异步更新实现原理</span></a></h2><h3 id="vue-2-基于-watcher-的异步更新机制" tabindex="-1"><a class="header-anchor" href="#vue-2-基于-watcher-的异步更新机制"><span><strong>Vue 2：基于 Watcher 的异步更新机制</strong></span></a></h3><p>在 <strong>Vue 2</strong> 中，组件的渲染与数据变动更新是通过 <strong>Watcher</strong> 完成的。<br> 每个响应式数据都会对应若干个 Watcher（包括渲染 Watcher 和用户定义的 Watcher）。</p><p><strong>1. 异步队列机制</strong>：当数据发生变化时，Vue 不会立刻执行 DOM 更新，而是将对应的 Watcher 推入一个 <strong>异步更新队列</strong>（<code>queue</code>）中 <strong>2. 去重机制</strong>：为了避免同一个 Watcher 在一个事件循环中被多次执行（例如连续修改同一个数据），Vue 通过一个 <code>has</code> 哈希表来去重 <strong>3. 异步调度</strong>Vue 使用 <code>nextTick</code> 异步地在当前事件循环结束后（宏任务或微任务）统一执行队列中的所有 Watcher <strong>4. 执行过程</strong></p><ol><li>数据变化 → <code>dep.notify()</code></li><li>收集到相关的 Watcher → 推入异步队列</li><li>在下一次事件循环中执行 <code>flushSchedulerQueue()</code></li><li>所有 Watcher 执行更新逻辑（触发重新渲染）</li></ol><h3 id="vue-3-基于-effect-的异步更新机制" tabindex="-1"><a class="header-anchor" href="#vue-3-基于-effect-的异步更新机制"><span><strong>Vue 3：基于 effect 的异步更新机制</strong></span></a></h3><p>在 <strong>Vue 3</strong> 中，响应式系统完全重写，使用 <strong>Proxy + effect（副作用函数）</strong> 来实现依赖追踪和更新。</p><p><strong>1. effect 依赖收集</strong> 每当在 <code>effect()</code> 中访问响应式数据时，Vue 会自动进行依赖收集：内部会把当前的 effect 函数与依赖的响应式对象关联起来。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">effect</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  // 访问响应式数据</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">state</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2. 异步调度器 (scheduler)</strong>：当响应式数据变化时，不会立即执行 effect，而是通过调度器（<code>scheduler</code>）来异步调度执行：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">effect</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> /* 更新视图 */</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">  scheduler</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> queueJob</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>queueJob</code> 的作用类似于 Vue2 的异步更新队列，内部实现：</p><ul><li>将 job（即 effect）加入任务队列；</li><li>去重相同的 job；</li><li>使用微任务（<code>Promise.then</code>）在下一次事件循环中批量执行。 <strong>3. 异步队列执行</strong>：Vue3 内部的 <code>queueJob()</code> 和 <code>flushJobs()</code> 实现与 Vue2 类似：</li></ul><h3 id="总结对比" tabindex="-1"><a class="header-anchor" href="#总结对比"><span><strong>总结对比</strong></span></a></h3><table><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td>响应式核心</td><td><code>Object.defineProperty</code> + <code>Watcher</code></td><td><code>Proxy</code> + <code>effect</code></td></tr><tr><td>更新调度</td><td>异步队列（Watcher 队列）</td><td>异步队列（Job 队列）</td></tr><tr><td>去重机制</td><td>通过 <code>has</code> 标记去重</td><td>通过 <code>Set</code> 自动去重</td></tr><tr><td>执行时机</td><td><code>nextTick</code> (微任务/宏任务)</td><td><code>queueJob</code> (微任务)</td></tr><tr><td>实现方式</td><td>Watcher 收集依赖</td><td>effect 收集依赖</td></tr><tr><td>更新策略</td><td>多次修改 → 合并成一次更新</td><td>多次修改 → 合并成一次更新</td></tr></tbody></table><h2 id="nexttick实现" tabindex="-1"><a class="header-anchor" href="#nexttick实现"><span>nexttick实现</span></a></h2><p>vue也提供了nexttick api给开发者使用，可以在页面数据更新后获取更新后的数据，用来在 <strong>DOM 更新完成后</strong> 执行回调。</p><p>选择异步任务的优先级是：如果不支持则采用下一种方式实现 <code>Promise.then</code>-&gt;<code>MutationObserver</code>-&gt;<code>setImmediate</code>-&gt;<code>setTimeout</code></p>`,23)])])}const c=s(n,[["render",d]]),l=JSON.parse('{"path":"/frontend/1ao1dtck/","title":"nexttick","lang":"zh-CN","frontmatter":{"title":"nexttick","createTime":"2025/10/15 16:53:18","permalink":"/frontend/1ao1dtck/"},"readingTime":{"minutes":2.88,"words":863},"git":{"createdTime":1760518648000,"updatedTime":1760518648000,"contributors":[{"name":"jueer33","username":"jueer33","email":"jueer33@gmail.com","commits":1,"avatar":"https://avatars.githubusercontent.com/jueer33?v=4","url":"https://github.com/jueer33"}]},"filePathRelative":"notes/前端相关/vue/8.nexttick.md","headers":[]}');export{c as comp,l as data};
