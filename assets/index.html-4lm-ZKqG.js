import{_ as n,c as e,e as a,b as t,d as s,a as h,w as k,r as d,o as r}from"./app-CeRryCsJ.js";const p={};function o(g,i){const l=d("VPLink");return r(),e("div",null,[i[3]||(i[3]=a(`<h2 id="一、render和虚拟节点" tabindex="-1"><a class="header-anchor" href="#一、render和虚拟节点"><span>一、render和虚拟节点</span></a></h2><p>在vue中渲染流程为：</p><blockquote><p>模板 → render 函数 → 生成 VNode 树 → diff 新旧 VNode → patch 到真实 DOM</p></blockquote><p>所以要知道diff算法首先要知道render函数和虚拟节点是什么</p><h3 id="_1-1-虚拟节点" tabindex="-1"><a class="header-anchor" href="#_1-1-虚拟节点"><span>1.1 虚拟节点</span></a></h3><p>虚拟节点（VNode, Virtual DOM Node）是对真实 DOM 的一种抽象表示。它用一个普通的 JavaScript 对象来描述 DOM 结构和属性。 Vue 在编译模板时会把模板编译成 render 函数，而 render 函数执行后返回的就是一颗 <strong>VNode 树</strong>。 <strong>关键属性：</strong></p><ul><li><code>tag</code>：标记是元素还是组件</li><li><code>data</code>：存放属性、事件、指令等</li><li><code>children</code>：子 VNode 数组</li><li><code>text</code>：文本节点用</li><li><code>key</code>：列表 diff 过程中的唯一标识（很重要）</li><li><code>elm</code>：指向真实 DOM 元素，只有在 patch 挂载后才有</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">div</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">              // 标签名，如果是组件则是组件的构造函数</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  data</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">                  // 数据对象 (属性/样式/事件)</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    attrs</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> id</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">app</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    style</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> color</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">red</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">    on</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> click</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> fn</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  },</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  children</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> [</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">              // 子节点（VNode 数组）</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    {</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">span</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> text</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">hello</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    {</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> tag</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">span</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> text</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">world</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> ...</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  ],</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  text</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> undefined</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">         // 文本节点时才有值</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  elm</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> undefined</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">          // 对应的真实 DOM，patch 阶段会填充</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">xxx</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">              // key，diff 时用来优化复用</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  componentOptions</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> null</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">   // 如果是组件，会保存组件的配置信息</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-render函数" tabindex="-1"><a class="header-anchor" href="#_1-2-render函数"><span>1.2 render函数</span></a></h3><p>Vue 提供了一个 <code>h()</code> 函数用于创建 vnodes：<a href="https://cn.vuejs.org/guide/extras/render-function" target="_blank" rel="noopener noreferrer">render函数</a><code>render()</code> 函数接收一个参数，即 Vue 的 <code>h</code> 函数（也称为 <code>createElement</code> 函数），用于创建虚拟 DOM 节点。<a href="https://www.runoob.com/vue3/vue3-api-render.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">import</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> h</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> from</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">vue</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">export</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> default</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  render</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">h</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> h</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">div</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;"> class</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">container</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> },</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Hello, Vue3!</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二、vue2-diff" tabindex="-1"><a class="header-anchor" href="#二、vue2-diff"><span>二、vue2 diff</span></a></h2><blockquote><p>diff 算法的实现就是：对比新旧虚拟节点（VNode 树），找到最小的差异，然后有选择地更新真实 DOM，而不是全部重建。</p></blockquote><h3 id="_2-1-对比更新流程" tabindex="-1"><a class="header-anchor" href="#_2-1-对比更新流程"><span>2.1 对比更新流程</span></a></h3>`,14)),t("p",null,[i[1]||(i[1]=s("由deepseek生成流程图如下： ",-1)),h(l,{href:"assets/image-1.pdf"},{default:k(()=>[...i[0]||(i[0]=[s("由deepseek生成流程图",-1)])]),_:1}),i[2]||(i[2]=s(" 每次都从根节点开始比较，",-1))]),i[4]||(i[4]=a('<ul><li>如果key值相同就复用这个根节点，把新节点的elm指向旧节点中的所指向的真实节点，</li><li>如果不相同就弃用原来的节点重新新建节点，如果key值相同的情况下还要比对它的子节点，由于子节点是数组，在这里vue的比对原则是尽量不新增不移动原来的节点 设置四个指针，分别指向新旧节点的头尾指针，<code>OldHead,OldTail,NewHead,NewTail</code></li></ul><ol><li><strong>头头比较</strong><ul><li><code>OldHead</code> vs <code>NewHead</code></li><li>如果 <code>key</code> 相同 → 说明节点位置没变，直接 patch 并递归比对子节点</li><li>两个指针同时右移</li></ul></li><li><strong>尾尾比较</strong><ul><li><code>OldTail</code> vs <code>NewTail</code></li><li>如果 <code>key</code> 相同 → 说明尾部节点没变，直接 patch 并递归比对子节点</li><li>两个指针同时左移</li></ul></li><li><strong>交叉比较（头尾、尾头）</strong><ul><li><strong>旧头 vs 新尾</strong><ul><li>如果相同 → 说明节点从前移到后</li><li>直接 patch 并移动 DOM 到尾部位置</li><li><code>OldHead++</code>，<code>NewTail--</code></li></ul></li><li><strong>旧尾 vs 新头</strong><ul><li>如果相同 → 说明节点从后移到前</li><li>直接 patch 并移动 DOM 到头部位置</li><li><code>OldTail--</code>，<code>NewHead++</code></li></ul></li></ul></li><li>四个快速路径都没命中 → keyMap 查找 <ul><li>用新节点的 key 去旧节点里查找</li><li>如果找到了：说明这个节点可以复用，直接移动并 patch</li><li>如果没找到：说明是新节点，创建新 DOM 插入</li></ul></li><li>遍历结束后的收尾操作 <ul><li><strong>旧节点数组还有剩余</strong> → 说明这些节点不需要了，直接移除</li><li><strong>新节点数组还有剩余</strong> → 说明是新增节点，依次创建并插入</li></ul></li></ol><h2 id="三、vue3" tabindex="-1"><a class="header-anchor" href="#三、vue3"><span>三、vue3</span></a></h2><p>Vue3 相比 Vue2 在 <strong>核心思想上相同（新旧 VNode 树比对，最小化 DOM 操作）</strong>，但做了两大优化：</p><ul><li><strong>静态标记</strong>（PatchFlag） → 减少无关节点的比对</li><li><strong>最长递增子序列（LIS）优化</strong> → 减少不必要的 DOM 移动</li></ul><h3 id="_3-1-vue3-diff-流程" tabindex="-1"><a class="header-anchor" href="#_3-1-vue3-diff-流程"><span>3.1 Vue3 Diff 流程</span></a></h3><p>在 Vue3 中，依旧是从根节点开始：</p><ol><li><strong>根节点比较</strong><ul><li>如果 <code>type</code>（标签名 / 组件类型）不同 → 直接卸载旧节点，新建新节点。</li><li>如果相同 → 复用 DOM，并对比 <code>props</code>（属性）、<code>children</code>（子节点）。</li></ul></li><li><strong>子节点比对：分 3 种情况</strong><ul><li><strong>文本节点</strong> → 直接更新 <code>textContent</code>。</li><li><strong>数组节点</strong> → 执行 <code>patchKeyedChildren</code>（核心 diff 算法）。</li><li><strong>空节点 → 非空</strong> / <strong>非空 → 空</strong> → 直接插入 / 删除。</li></ul></li><li><strong>数组节点的 diff（patchKeyedChildren）</strong><ol><li><strong>前后指针对比</strong><ul><li><code>oldHead</code> vs <code>newHead</code> → 相同则递归 patch，指针右移。</li><li><code>oldTail</code> vs <code>newTail</code> → 相同则递归 patch，指针左移。</li></ul></li><li><strong>前后指针没有对比成功→ 进入乱序比对：</strong><ul><li>构建 <strong>新子节点的 key → index 映射表</strong>。</li><li>遍历旧子节点，看是否能在新表中找到： <ul><li>找到 → 说明可复用，打上“位置变更”标记。</li><li>找不到 → 说明节点被删除。</li></ul></li></ul></li><li><strong>根据映射表生成映射序列</strong><ul><li>得到一组“新节点的对应旧节点下标数组”。</li><li>在这组数组上运行 <strong>最长递增子序列（LIS）算法</strong>，得到哪些节点“顺序没变”。</li></ul></li><li><strong>移动节点 &amp; 新建节点</strong><ul><li>LIS 里的节点 → 顺序正确，不需要移动。</li><li>不在 LIS 里的节点 → 要么是新增（创建），要么是已有节点需要移动。</li></ul></li></ol></li><li><strong>收尾处理</strong><ul><li>新数组比旧数组长 → 创建多出来的新节点。</li><li>新数组比旧数组短 → 删除多余的旧节点。</li></ul></li></ol><h3 id="_3-2-vue2-vs-vue3-的关键区别" tabindex="-1"><a class="header-anchor" href="#_3-2-vue2-vs-vue3-的关键区别"><span>3.2 vue2 vs Vue3 的关键区别</span></a></h3><p>Vue2 的 diff 算法采用四指针逐步比对并即时移动节点，可能导致较多的 DOM 操作；而 Vue3 在比对中先确定复用关系，再通过最长递增子序列找出无需移动的节点，最后统一移动和新增删除，从而最大限度减少 DOM 操作并结合静态标记优化性能。</p><ul><li><strong>Vue2</strong><ul><li>采用 <strong>四指针法</strong>（<code>OldHead</code>、<code>OldTail</code>、<code>NewHead</code>、<code>NewTail</code>）。</li><li>每次比对时，尝试通过头头、尾尾、交叉比对来找到可以复用的节点。</li><li>一旦找到可复用的节点，就立即移动指针并进行 patch 操作。</li><li>整个过程中，节点的移动是 <strong>逐步完成的</strong>。</li></ul></li><li><strong>Vue3</strong><ul><li>依旧会做前后指针对比来处理头尾部分快速命中的情况。</li><li>进入乱序比对阶段时，不会立即移动 DOM。</li><li>而是先 <strong>通过 key 建立映射表</strong>，找出哪些旧节点能复用。</li><li>再生成新旧节点的对应下标序列，利用 <strong>最长递增子序列（LIS）算法</strong> 找出“顺序没变的节点”。</li><li>最后 <strong>统一执行节点移动和新增删除操作</strong>，减少了 DOM 的频繁操作。</li></ul></li></ul><table><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td><strong>比对方式</strong></td><td>四指针（头尾 + 交叉对比）+ keyMap</td><td>先前后指针 → 剩余乱序比对 + <strong>LIS 优化</strong></td></tr><tr><td><strong>性能优化</strong></td><td>只做双端比对，可能频繁移动节点</td><td><strong>最长递增子序列</strong>，尽量减少 DOM 移动</td></tr><tr><td><strong>静态优化</strong></td><td>无</td><td><strong>PatchFlag</strong> 静态标记：跳过不需要 diff 的节点</td></tr></tbody></table>',12))])}const y=n(p,[["render",o]]),u=JSON.parse('{"path":"/frontend/qsvkemiu/","title":"vue的diff算法","lang":"zh-CN","frontmatter":{"title":"vue的diff算法","createTime":"2025/10/06 19:59:05","permalink":"/frontend/qsvkemiu/"},"readingTime":{"minutes":5.73,"words":1720},"git":{"createdTime":1759677387000,"updatedTime":1759753861000,"contributors":[{"name":"jueer33","username":"jueer33","email":"jueer33@gmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/jueer33?v=4","url":"https://github.com/jueer33"}]},"filePathRelative":"notes/前端相关/vue/3.vue的diff算法.md","headers":[]}');export{y as comp,u as data};
