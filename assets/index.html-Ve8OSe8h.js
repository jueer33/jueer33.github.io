import{_ as t,c as o,e as a,o as i}from"./app-CeRryCsJ.js";const r={};function l(c,e){return i(),o("div",null,[...e[0]||(e[0]=[a("<p>在vue3中keep-alive可以实现组件的缓存，是 Vue 内置的抽象组件，用来 <strong>缓存组件的实例</strong>，避免重复创建和销毁，从而保留组件的状态（比如表单输入、滚动位置等）。</p><ol><li><p><strong>抽象组件</strong></p><ul><li><code>keep-alive</code> 自己不会渲染真实 DOM，只是包裹子组件。</li><li>Vue 内部通过 <code>abstract: true</code> 标记它，不会影响父子关系。</li></ul></li><li><p><strong>缓存机制（cache Map）</strong></p><ul><li>内部维护一个 <code>cache</code>（通常是 <code>Map</code> 或 <code>Object</code>）。</li><li>key：由组件的 <code>name</code> + <code>key</code> 生成。</li><li>value：组件的 <strong>VNode + 组件实例</strong>。</li></ul></li><li><p><strong>首次渲染</strong>:当子组件第一次被渲染时： keep-alive 会把生成的 VNode 和实例存到 cache 里。</p></li><li><p><strong>再次激活</strong>:当切换回来时，不会重新 mount，而是直接从 cache 里取出之前的实例和 DOM，执行 activated 钩子，而不是 created/mounted。</p></li><li><p><strong>失活</strong>（inactive）:被切换走的组件不会销毁，而是执行 deactivated 钩子，DOM 会被移动到一个隐藏的容器里（storage container）。</p></li><li><p><strong>LRU 策略（max 缓存数）</strong>:如果设置了 :max，缓存超过数量会使用 LRU（最近最少使用） 策略，把最久未访问的实例销毁，腾出空间。</p></li></ol>",2)])])}const s=t(r,[["render",l]]),d=JSON.parse('{"path":"/frontend/38lhy4lx/","title":"keep-alive原理","lang":"zh-CN","frontmatter":{"title":"keep-alive原理","createTime":"2025/10/06 19:59:05","permalink":"/frontend/38lhy4lx/"},"readingTime":{"minutes":1.04,"words":313},"git":{"createdTime":1759677387000,"updatedTime":1759753861000,"contributors":[{"name":"jueer33","username":"jueer33","email":"jueer33@gmail.com","commits":2,"avatar":"https://avatars.githubusercontent.com/jueer33?v=4","url":"https://github.com/jueer33"}]},"filePathRelative":"notes/前端相关/vue/4.keep-alive原理.md","headers":[]}');export{s as comp,d as data};
